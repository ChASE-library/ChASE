/*! \file lanczos.hpp
 *      \brief Header file for Lanczos algorithm
 *      \details This file contains a single function, which is a partial implementation of the Lanczos algorithm,
 *      to the extent we neeed in our algorithm.
 *  */

/// \cond

#ifndef ELECHFSI_LANCZOS
#define ELECHFSI_LANCZOS

#include "El.hpp"
using namespace El;
using namespace std;

/// \endcond

/** \fn lanczos(ApplyAClass applyA, DistMatrix<F>& V,
             const int ub_iter, const int block, const int max_iter,
             DistMatrix<R,VR,STAR>& Lambda, R* const upper)
 * \brief Implementation of the Lanczos algorithm.
 * \details This function implements the Lancsos algorithms
 * up to an extent needed for our algorithm. Namely, a few iterations of the Lancsos algorithm are used in the first steps of ChASE
 * to give an upper estimate of the eigenvalue spectrum. The vectors with eigenvalues larger than this value, are to be suppressed by the filter.
 * This function also calls an Elemental direct tridiagonal eigensolver, in order to compute the eigenvalues of the the arrising tridiagonal
 * eigensystem, generated by the partial Lanczos procedure.
 * \param applyA        Function which accepts ElementalMatrix<F> X and Y and returns Y := alpha A X + beta Y, where A is Hermitian
 * \param ub_iter       Integer specifying the number of Lanczos iterations used to bound the spectral interval.
 * \param block         Integer specifying the number Ritz values to approximate for the Random version of ChASE, set to ub_iter if not needed.
 * \param max_iter      Integer specifying the number of Lanczos iterations that are to be run.
 * \param V             Elemental DistMatrix of template type F. Outputs the approximate eigenvectors for the first system in
 *                                      the sequence, in case the algorithm is run with "random" parameter. Each vector is a separate column in the matrix V.
 * \param Lambda        Elemental DistMatrix of doubles. Outputs the guessed eigenvalues on exit, if ub_iter /= block on input.
 * \param upper Pointer of type R (double). Contains a single real value, the upper bound estimate of the eigenvalue spectrum.
 * \return void
 */
template<typename F,class ApplyAClass>
void lanczos
( const ApplyAClass& applyA,
  DistMatrix<F>&     v,
  const int          min_iter,
  const int          max_iter,
  const int          block,
  Base<F>* const     upper,
  Base<F>* const     lower,
  Base<F>* const     lambda)
{
  typedef Base<F> Real;
  const Grid& grid = v.Grid();
  const Int n = v.Height();

  Real alpha_r, beta_r;
  F    alpha_c, beta_c;

  DistMatrix<F>  z(n, 1, grid);
  DistMatrix<F> v0(n, 1, grid);

  Matrix<Real> dd(min_iter, 1);
  Matrix<F>    ee(min_iter, 1);
  Matrix<Real> ww(min_iter, 1);
  Matrix<F>    ZZ(min_iter, min_iter);

  DistMatrix<Real> d_(max_iter, 1, grid);
  DistMatrix<F>    e_(max_iter, 1, grid);
  DistMatrix<Real> w_(max_iter, 1, grid);

  alpha_r = Nrm2(v);

  alpha_c = F(1/alpha_r);
  Scale(alpha_c, v);

  Zeros(v0, n, 1);

  beta_r = 0;

  for (int k = 0; k < max_iter; )
  {
      applyA( F(1), v, F(0), z );

      alpha_c = Dot(z, v);
      Axpy(-alpha_c, v, z);
      Axpy(F(-beta_r), v0, z);

      beta_r = Nrm2(z);

      v0 = v;
      Zeros(v, n, 1);
      Axpy(F(1/beta_r), z, v);

      if (k < min_iter)
      {
          dd.Set(k, 0, RealPart(alpha_c));
          ee.Set(k, 0, beta_r);
      }

      if (block != min_iter)
      {
          d_.Set(k, 0, RealPart(alpha_c));
          if (k < max_iter) e_.Set(k, 0, beta_r);
      }

      k += 1;
      if (k == min_iter)
      {
          HermitianTridiagEig(dd, ee, ww, ZZ, ASCENDING);

          Real* w = ww.Buffer();
          F*    Z = ZZ.Buffer();
          alpha_r = fabs(w[0]) > fabs(w[k-1]) ? fabs(w[0]) : fabs(w[k-1]);

          *upper = alpha_r + fabs(beta_r)*fabs(Z[(k-1)*k+k-1]);
      }
  }

  if (lower != NULL && lambda != NULL)
  {
      HermitianTridiagEig(d_, e_, w_, ASCENDING);

      *lower  = w_.Get(block, 0);
      *lambda = w_.Get(0, 0);
  }

  mpi::Barrier(grid.Comm());
}

#endif  // ELECHFSI_LANCZOS
