************************************
How to use ChASE
************************************

Use ChASE as a standalone solver
=====================================


Include headers
------------------

In order to use ChASE in an application code written in ``C/C++`` 
the following files have to be included in the header file.

.. code-block:: c++

    /*Performance Decorator of ChASE*/
    #include "algorithm/performance.hpp"

    /*Common interface of ChASE-MPI*/
    #include "ChASE-MPI/chase_mpi.hpp"

    /*USE ChASE-MPI without GPUs*/
    /*With MPI support for distributed-memory system*/
    #include "ChASE-MPI/impl/chase_mpidla_blaslapack.hpp"
    /*Without MPI support for single-node system*/
    #include "chase_mpidla_blaslapack_seq.hpp"

    /*USE ChASE-MPI with GPUs*/
    /*With MPI support for distributed-memory system*/
    #include "ChASE-MPI/impl/chase_mpidla_mgpu.hpp"
    /*Without MPI support for single-node system*/    
    #include "ChASE-MPI/impl/chase_mpidla_cuda_seq.hpp"


How to use ChASE from own application
======================================

In order to embed the ChASE library in an application software, ChASE
can be opportunely linked following the instructions in this section.

In this section, we give the guidelines for the integration
of the ChASE library into a given application software. 


.. _link_by_cmake:

Compiling with ChASE
-------------------------------

CMake
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``CMakeLists.txt`` (see code window below) is an example on how to link ChASE installation
using CMake. In this example ChASE is linked to a source file named ``chase_app.cpp``.
The ``CMakeLists.txt`` should then be included in the main directory
of the application software as well as the ``chase_app.cpp`` file.

.. code-block:: cmake

   cmake_minimum_required(VERSION 3.8)

   project(chase-app VERSION 0.0.1 LANGUAGES CXX)

   #find installation of ChASE
   find_package( chase REQUIRED CONFIG)

   add_executable(${PROJECT_NAME})

   # add the source file of application
   target_sources(${PROJECT_NAME} PRIVATE chase_app.cpp)

   # link to ChASE
   target_link_libraries(${PROJECT_NAME} PUBLIC ChASE::chase_mpi)

   # if users want to compile the application with multi-GPU version of ChASE
   # the target should be linked to the both the library ChASE::chase_mpi
   # and the library ChASE::chase_cuda
   target_link_libraries(${PROJECT_NAME} PUBLIC ChASE::chase_cuda)

With CMake, the application software can be compiled by the following commands:

.. code-block:: console

   mkdir build & cd build
   cmake .. -DCMAKE_PREFIX_PATH=${ChASEROOT}
   make

`example: 3_installation <https://github.com/ChASE-library/ChASE/tree/master/examples/3_installation>`_
provides an example which illustrates the way to link ChASE by CMake with or without GPU supports.

.. note::
  We highly recommand to link ChASE with CMake. The installation of ChASE allows to use CMake to find and link it easily.


Makefile
^^^^^^^^^^^^^^^^^^^^

Similar as the direct linking, it is also possible to link ChASE by ``Makefile``. 
Here below is a template of this ``Makefile`` for `example: 3_installation <https://github.com/ChASE-library/ChASE/tree/master/examples/3_installation>`_.

.. code-block:: Makefile

  ChASEROOT = /The/installation/path/of/ChASE/on/your/platform

  CXX = mpicxx #or other mpi CXX compiler

  CXXFLAGS = \
      -Wall -fopenmp -MMD \

  INCLUDE_DIR = ${ChASEROOT}/include #include the headers of ChASE

  LIBS_BLASLAPACK = /your/BLAS/LAPACK/SCALAPACK/LIBRARIES

  ## Optional for multi-GPU version of ChASE ##
  LIBS_CUDA = -lcublas -lcusolver -lcudart -lcurand ## link to the libraries of cuBLAS, cuSOLVER and CUDA runtime

  ## Optional for multi-GPU version of ChASE ##
  LIBS_CHASE_CUDA = ${ChASEROOT}/lib64/libchase_cuda.a

  chase-app: LIBS = ${LIBS_BLASLAPACK} #executable generated by chase-app.cpp

  chase-app-gpu: LIBS = ${LIBS_BLASLAPACK} -L${LIBS_CHASE_CUDA} ${LIBS_CUDA} #executable generated by chase-app-gpu.cpp

  src = ${wildcard *.cpp}
  exe = ${basename ${src}}

  all: $(exe)

  .SUFFIXES:

  %: %.cpp
          ${CXX} ${CXXFLAGS} ${LIBS} -I${INCLUDE_DIR} -o $@ $<

  clean:
          -rm -f $(exe) *.o

  -include *.d


Interface to C/Fortran
======================================

C Interface 
-----------


Fortran Interface
------------------

Examples
-----------


Example of C interface
^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: C

  ...
  ...

  void pzchase_init_(int* N, int* nev, int* nex, int* m, int* n,
                     double _Complex* H, int* ldh, double _Complex* V,
                     double* ritzv, int* dim0, int* dim1, char* grid_major,
                     MPI_Comm* comm, int* init);
  void pzchase_finalize_(int* flag);
  void pzchase_(int* deg, double* tol, char* mode, char* opt);

  int main(int argc, char** argv)
  {
      MPI_Init(&argc, &argv);
      int rank = 0, init;

      int N = 1001; //global size of matrix
      int nev = 100; //number of eigenparis to compute
      int nex = 40; //size of external searching space
      int m = 501; //number of rows of local matrix on each MPI rank
      int n = 501; //number of columns of local matrix on each MPI rank
      MPI_Comm comm = MPI_COMM_WORLD; //working MPI communicator
      int dims[2];
      dims[0] = 2; //row number of 2D MPI grid
      dims[1] = 2; //column number of 2D MPI grid
      //allocate buffer to store computed eigenvectors
      double _Complex* V = (double _Complex*)malloc(sizeof(double _Complex) * m * (nev + nex));
      //allocate buffer to store computed eigenvalues    
      double* Lambda = (double*)malloc(sizeof(double) * (nev + nex));
      //allocate buffer to store local block of Hermitian matrix on each MPI rank
      double _Complex* H = (double _Complex*)malloc(sizeof(double _Complex) * m * n);

      // config
      int deg = 20;
      double tol = 1e-10;
      char mode = 'R';
      char opt = 'S';

      //Initialize of ChASE
      pzchase_init_(&N, &nev, &nex, &m, &n, H, &m, V, Lambda, &dims[0], &dims[1],
                    (char*)"C", &comm, &init);

      /*
          Generating or loading matrix into H
      */

      //solve with defined configuration of parameters
      pzchase_(&deg, &tol, &mode, &opt);

      //finalise and clean up
      pzchase_finalize_(&init);

      MPI_Finalize();
  }


Example of Fortran interface
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: Fortran

  PROGRAM main
  use mpi
  use chase_diag !use chase fortran interface module

  integer ierr, init, comm
  integer m, n
  integer dims(2)
  integer nn, nev, nex
  real(8) :: tol
  integer :: deg
  character        :: mode, opt, major
  complex(8),  allocatable :: h(:,:), v(:,:)
  real(8), allocatable :: lambda(:)

  call mpi_init(ierr)

  nn = 1001 ! global size of matrix
  nev = 100 ! number of eigenparis to compute
  nex = 40 ! size of external searching space

  comm = MPI_COMM_WORLD ! working MPI communicator
  ! config
  deg = 20
  tol = 1e-10
  mode = 'R'
  opt = 'S'
  major = 'C'

  dims(1) = 2 ! row number of 2D MPI grid
  dims(2) = 2 ! column number of 2D MPI grid

  m = 501 ! number of rows of local matrix on each MPI rank
  n = 501 ! number of columns of local matrix on each MPI rank

  allocate(h(m, n)) ! allocate buffer to store local block of Hermitian matrix on each MPI rank
  allocate(v(m, nev + nex)) ! allocate buffer to store computed eigenvectors
  allocate(lambda(nev + nex)) ! allocate buffer to store computed eigenvalues

  ! Initialize of ChASE
  call pzchase_init(nn, nev, nex, m, n, h, m, v, lambda, dims(1), dims(2), major, comm, init)

  !
  !      Generating or loading matrix into H
  !

  ! solve with defined configuration of parameters
  call pzchase(deg, tol, mode, opt)
  ! finalise and clean up
  call pzchase_finalize(init)

  call mpi_finalize(ierr)


  END PROGRAM





